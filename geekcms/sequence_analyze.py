
"""
Syntax:
    start       : NEWLINE lines end
                | lines end

    end         : plugin_expr
                | empty

    lines       : lines line_atom
                | empty

    line_atom   : plugin_expr NEWLINE

    plugin_expr : plugin_name relation plugin_name
                | plugin_name relation
                | relation plugin_name
                | plugin_name

    relation    : left_rel
                | right_rel

    left_rel    : LEFT_OP
                | LEFT_OP DEGREE

    right_rel   : RIGHT_OP
                | DEGREE RIGHT_OP

    plugin_name : IDENTIFIER

    empty       : <empty>

Semantics:
    1. "pre_load: my_loader": register plugin "my_loader" to component
    "pre_load".
    2. "pre_load: my_loader << my_filter": register plugins "my_loader" and
    "my_filter" to component "pre_load", with "my_loader" being executed before
    "my_filter".
    3. "pre_load: my_filter >> my_loader": has the same meaning as
    "pre_load: my_loader << my_filter".
    4. "pre_load: loader_a <<0 loader_b NEWLINE loader_c <<1 loader_b" the
    execution order would be "loader_c" --> "loader_a" --> "loader_b".
    "<<" is equivalent to "<<0", and "<< decimalinteger" is equivalent to
    "decimalinteger >>".
    5. "pre_load: my_loader <<": means "my_loader" would be executed before the
    other plugins within a component, unless another relation such as
    "anther_loader <<1" is established.
    6. "pre_load: >> my_filter": reverse meaning of "pre_load: my_loader <<".

Algorithm:
    1. lexical analysis and Syntax Checking: Performed by PLY, extract plugin
    relation expression from each physical line, transform to the format of
    'x <<p y'. Some important syntax directed actions are as follow:
        1.1 Extract left operand, operator and right operand.
        1.2 If x is missed, HEAD is added as x; If y is missed, TAIL is added
        as y;
        1.3 For expressions that only consist of one operand and no operator,
        for example, 'x NEWLINE', the only operand in the expression would be
        considered as the left operand, with no relation and right operand.
        1.4 '<<' is transform to '<<0', and so '>>'.
    2. Preparation for generating plugin execution order.
        2.1 Transform 'x p>> y' to 'y <<p x'.
        2.2 Transform operand to the form of (theme, plugin), based on
        'theme.plugin'. If 'theme.' part is omitted, then automatically
        generate theme with respect to file's directory(where relation
        expressions were loaded).
        2.3 Expressions that has left operand with no relation and right
        operand, would be removed and kept in somewhere else. Such expressions
        would not be used to generating relation group(step 3).
    3. Generate relation groups.
    A relation group: {(x <<p y)| for x, all avaliable (p, y) in expressions}.
        3.1 Sort expressions(x <<p y) with respect to x's value, then with p's
        value. Generate raw relation groups.
        3.2 For every raw relation groups, tranlate all its relations
        (x <<p1 y1, x <<p2 y2, ..., x <<pn yn) to (x < y1, y1 < y2, ...,
        yn-1 < yn). Notice that '<' means 'x is executed earlier then y', in
        order to distingush with '<<', since 'x << y1, x << y2' would cause
        syntax error.
        3.3 Sort expressions generated by 3.2, regenerate relation groups.
    4. Generate order of plugin execution.
        Input: sorted relation groups.
        Output: sequence of plugin execution.

        order = a queue
        left_behind = a set initiated with items removed in 2.3.
        for i = next relation group:
            x = i's left operand(same in expression of a relation group)
            y_set = i's all right operands.

            if x in left_behind, remove x from left_behind.
            push x to order(append it).

            for y in y_set:
                if y in queue:
                    stop processing, there must be error.
                else:
                    add y to left_behind it y not in left_behind.

        if left_behind is not empty, then push all its items to order.
        return order
    5. Remove HEAD and TAIL from order.
"""

import inspect
from .parser.simple_lex import lexer
from .parser.simple_yacc import parser
from .parser.utils import ErrorCollector
from .parser.utils import PluginExpr
from .protocal import PluginIndex


class SequenceParser:

    def __init__(self):
        self.error = False
        self.theme_plugin_expr_mapping = dict()
        # bind parser with lexer
        self._parse = inspect.partial(parser.parse, lexer=lexer)

    # implement 2.2
    def _replace_with_plugin_index(self, theme, plugin_exprs):

        def get_theme_plugin(operand):
            if operand == PluginExpr.HEAD or operand == PluginExpr.TAIL:
                return None, operand
            # theme.plugin or plugin
            items = operand.split('.')
            if len(items) == 1:
                return theme, operand
            elif len(items) == 2:
                return items
            else:
                raise SyntaxError('Operand Error.')

        processed_exprs = []
        for expr in plugin_exprs:

            left_theme, left_plugin = get_theme_plugin(expr.left_operand)
            right_theme, right_plugin = get_theme_plugin(expr.right_operand)

            left_index = PluginIndex(left_theme, left_plugin)
            right_index = PluginIndex(right_theme, right_plugin)

            new_expr = PluginExpr(
                left_operand = left_index,
                right_operand = right_index,
                relation=expr.relation,
            )
            processed_exprs.append(new_expr)

        return processed_exprs


    def analyze(self, theme, text):
        exprs = self._parse(text)
        processed_exprs = self._replace_with_plugin_index(theme, exprs)
        self.theme_plugin_expr_mapping[theme] = processed_exprs

        if ErrorCollector.lex_error:
            self.error = True
            ErrorCollector.archive_lex_messages(theme)

        if ErrorCollector.yacc_error:
            self.error = True
            ErrorCollector.archive_yacc_messages(theme)

    def report_error(self):
        # print lex error
        for theme, messages in ErrorCollector.theme_lex_error.items():
            # lineno not really the line number of 'settings' file.
            # might be improved in the future.
            val, lineno = messages
            template = "Theme '{}' >> Illegal Character: '{}' in line {}"
            print(template.format(theme, val, lineno))

        # print yacc error
        for theme, messages in ErrorCollector.theme_yacc_error.items():
            val, lineno, discard = messages
            template = ("Theme '{}' >> Syntax Error: '{}' in line {}"
                        "Discard: {}")
            print(template.format(theme, val, lineno, discard))

    def generate_sequence(self):
        pass


class _Algorithm:

    def __init__(self, plugin_exprs):
        self._plugin_exprs = plugin_exprs

    # implement 2.1
    def _transform_to_left_rel(self, plugin_exprs):
        pass

    # implement 2.3
    def _remove_irrelevant_exprs(self, plugin_exprs):
        pass

    # implement 3.1 and 3.3
    def _generate_relation_groups(self, plugin_exprs):
        pass

    # implement 3.2
    def _break_raw_relation_groups(self, relation_groups):
        pass

    # implement 4 and 5
    def _generate_execution_order(self, relation_groups, irrelevant_exprs):
        pass

    # Mix up all above functions.
    def generate_sequence(self):
        pass
