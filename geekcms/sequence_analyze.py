
"""
Algorithm:
    1. lexical analysis: extract plugin relation expression from each physical
    line, transform to the format of (x <<p y).
        1.1 Extract left operand, operator and right operand. For expressions
        that only consist of one operand and no operator, for example,
        'x NEWLINE', remove such expressions and keep it for later processing.
        1.2 Transform 'x [p]>> y' to 'y <<[p] x', then transform '<<' to '<<0'
        1.3 Transform operand to the form of (theme, plugin), based on
        'theme.plugin'. If 'theme.' part is omitted, then automatically
        generate theme with respect to file's directory(where relation
        expressions were loaded).
        1.4 If x is missed, HEAD is added as x; If y is missed, TAIL is added
        as y;
        1.5 Init with classes, including items removed in 1.1.
    2. Generate relation groups.
    A relation group: {(x <<p y)| for x, all avaliable (p, y) in expressions}.
        2.1 Sort expressions(x <<p y) with respect to x's value, then with p's
        value. Generate raw relation groups.
        2.2 For every relation groups, tranlate all its relations (x <<p1 y1,
        x <<p2 y2, ..., x <<pn yn) to (x < y1, y1 < y2, ..., yn-1 < yn). Notice
        that '<' means 'x is executed earlier then y', in order to distingush
        with '<<', since 'x << y1, x << y2' cause syntax error.
        2.3 Sort expressions generated by 2.2, regenerate relation groups.
    3. Generate order of plugin execution.
        Input: sorted relation groups.
        Output: sequence of plugin execution.

        order = a queue
        left_behind = a set initiated with items removed in 1.1.
        for i = next relation group:
            x = i's left operand(same in expression of a relation group)
            y_set = i's all right operands.

            if x in left_behind, remove x from left_behind.
            push x to order(append it).

            for y in y_set:
                if y in queue:
                    stop processing, there must be error.
                else:
                    add y to left_behind it y not in left_behind.

        if left_behind is not empty, then push all its items to order.
        return order
"""


class SequenceParser:

    def __init__(self, plain_text):
        pass
