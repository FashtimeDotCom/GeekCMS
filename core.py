from __future__ import unicode_literals
import markdown
import re
from datetime import datetime
import os
import copy

from settings import ARTICLE_DIR

class MarkdownArticle(object):
    """
    1. load markdown content from file.
    2. compiler markdown to html
    3. extract infomation of article, such as title, post time an so on.
    """

    def __init__(self, file_path):
        self._read_markdown_content(file_path)
        self._extract_article_info()
        self._compile_mardown_to_html()

    def _read_markdown_content(self, file_path):
        try:
            with open(file_path) as f:
                self.markdown_content = f.read()
        except Exception as e:
            # implement it later
            raise e
    
    def _compile_mardown_to_html(self):

        # first replace the info Key/Value pairs.
        def remove_info_pattern(markdown_content):
            info_pattern = '<!--\s+(\w|\W)+?\[(\w|\W)+?\]\s+-->'
            pattern = re.compile(info_pattern)
            content = pattern.sub('', markdown_content)
            return content

        content = remove_info_pattern(self.markdown_content)

        # then compile
        self.html = markdown.markdown(content)

    def _extract_article_info(self):
        """
        Infomation of article should be stored as following format:
        <!-- Key[Value] -->
        
        Avaliable Key/Value pairs is as follow:
        
        1. Key: Title, The title of article.
        2. Time: Article posted time, should be parsed by 
        datetime.strptime(Time, '%d/%m/%Y'), i.e. 1/11/2013
        """

        def title_parser(info):
            return info

        def time_parser(info):
            return datetime.strptime(info, '%d/%m/%Y')

        avaliable_keys = [
            ('Title', 'title', title_parser),
            ('Time', 'post_time', time_parser),
        ]

        info_pattern = '<!--\s+{}\[((\w|\W)+?)\]\s+-->'

        for key, cls_attr, parser in avaliable_keys:
            pattern = re.compile(info_pattern.format(key))
            match = pattern.search(self.markdown_content)
            try:
                info = match.group(1)
                info = parser(info)
                setattr(self, cls_attr, info)                
            except Exception as e:
                # implement it later
                raise e


class GenerateArticleTree(object):
    """
    1. dir node's sibling must be dir node,
    which file node's sibling must be file node.
    2. Only file with extension .md would be processed.
    3. The structure generated by this class would be presented by
    the combination of dict and list, which similar to JSON. Dict represents
    the directory, with key as the dir name and list(or dict) as files
    contained in dir.
    """

    def __init__(self):
        # construct article structure
        self._construct_article_structure()
        # construct article tree
        self._construct_article_tree()

    def _construct_article_structure(self):
        self.article_structure = {}

        def recursive_construct(cur_dir, path):
            # trick of making use of generator
            dirpath, dirnames, filenames = os.walk(path).next()

            # Rule 1
            if dirnames:
                for dirname in dirnames:
                    cur_dir[dirname] = {}
                    recursive_construct(
                        cur_dir[dirname],
                        os.path.join(dirpath, dirname),
                    )
            elif filenames:
                file_path_set = []
                for filename in filenames:
                    # Rule 2
                    if not filename.endswith('.md'):
                        continue
                    file_path = os.path.join(dirpath, filename)
                    file_path_set.append(file_path)
                # Rule 3
                cur_dir[None] = file_path_set

        recursive_construct(self.article_structure, ARTICLE_DIR)

    def _construct_article_tree(self):
        # deepcopy, might be a problem
        self.article_tree = copy.deepcopy(self.article_structure)
        
        def recursive_construct(dir):
            for sub_dir_name, sub_dir in dir.items():
                if sub_dir_name is None:
                    # construct MarkdownArticle list

                    # rename
                    file_path_set = sub_dir
                    markdown_article_set = []

                    for file_path in file_path_set:
                        markdown_article = MarkdownArticle(file_path)
                        markdown_article_set.append(markdown_article)
                    # hock to dir 
                    dir[None] = markdown_article_set
                else:
                    recursive_construct(sub_dir)

        recursive_construct(self.article_tree)
